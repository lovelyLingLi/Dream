<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>星际穿梭动画</title>
    <style>
        body, html {
            margin: 0;
            padding: 0;
            overflow: hidden;
            background: #000;
            height: 100%;
        }
        canvas {
            display: block;
            position: absolute;
            top: 0;
            left: 0;
        }
        .info {
            position: fixed;
            bottom: 20px;
            left: 20px;
            color: rgba(255,255,255,0.4);
            font-family: Arial, sans-serif;
            font-size: 14px;
            pointer-events: none;
            transition: opacity 1s;
            z-index: 10;
        }
        .container {
            position: relative;
            width: 100%;
            height: 100%;
            overflow: hidden;
        }
        .vignette {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: radial-gradient(circle, transparent 70%, rgba(0,0,0,0.7) 100%);
            pointer-events: none;
            z-index: 5;
        }
    </style>
</head>
<body>
<div class="container">
    <canvas id="starfield"></canvas>
    <div class="vignette"></div>
    <div class="info">移动鼠标改变观察方向</div>
</div>

<script>
    // 获取画布和上下文
    const canvas = document.getElementById('starfield');
    const ctx = canvas.getContext('2d');
    let W = canvas.width = window.innerWidth;
    let H = canvas.height = window.innerHeight;

    // 提示信息自动淡出
    const info = document.querySelector('.info');
    setTimeout(() => { info.style.opacity = '0'; }, 5000);

    // 参数设置
    const numStars = 3000;  // 星星数量
    const stars = [];

    let baseSpeed = 0.03;
    let targetAngleY = 0;
    let currentAngleY = 0;
    let maxAngleY = Math.PI / 3; // 30度限制

    // 创建渐变的宇宙背景色 - 调整为更深的蓝色调
    let bgGradient = ctx.createLinearGradient(0, 0, 0, H);
    bgGradient.addColorStop(0, '#010b18');  // 深蓝色顶部
    bgGradient.addColorStop(0.5, '#050616'); // 深蓝紫色中部
    bgGradient.addColorStop(1, '#08071a');  // 深蓝紫色底部

    // 星空背景图片
    const bgImage = new Image();
    let bgImageLoaded = false;

    // 如果有背景图片，可以在这里设置URL
    bgImage.src = './img2.png';

    bgImage.onload = () => {
        bgImageLoaded = true;
        console.log('Background image loaded');
    };

    bgImage.onerror = () => {
        console.error('Failed to load background image');
    };

    // 修改星星颜色分布 - 以蓝色为主，其次粉色，再次白色
    const starColors = [
        { color: 'rgb(106,169,252)', prob: 0.6 },  // 蓝色为主 (50%)
        { color: 'rgb(255,150,220)', prob: 0.3 },  // 粉色为次 (30%)
        { color: 'rgb(255,255,255)', prob: 0.1 }   // 白色最少 (20%)
    ];

    // 星星类
    class Star {
        constructor(isInitial = false) {
            this.reset(isInitial);
            // 随机速度因子 - 确保星星速度各不相同
            this.speedFactor = 0.4 + Math.random() * 2;

            // 拖尾历史记录
            this.trail = [];
            this.trailLength = 15 + Math.floor(Math.random() * 20);

            // 拖尾可见度初始值为0
            this.trailVisibility = 0;

            // 发光效果强度 - 随机值使得每颗星星发光效果不同
            this.glowIntensity = 0.6 + Math.random() * 0.8;
            this.glowSize = 2 + Math.random() * 2;
        }

        reset(isInitial = false) {
            const distributionFactor = 5;

            // 修改星星生成分布 - 主要在上半部分
            // 使用改进的分布算法，球面分布但偏向上半部分
            const r = Math.random() * W * 2 * distributionFactor;
            const theta = Math.random() * Math.PI * 2;

            // 修改phi的分布，使大部分星星生成在上半部分
            // -0.8~0.2的范围，大部分在负值区域(上半部分)
            const phi = (Math.random() * 1.0 - 0.8) * Math.PI;

            let x = r * Math.cos(phi) * Math.sin(theta);
            let y = r * Math.sin(phi);
            let z = r * Math.cos(phi) * Math.cos(theta);

            // 避免中心聚集
            const centerDist = Math.sqrt(x*x + y*y + z*z);
            if (centerDist < W * 0.5) {
                const scaleFactor = (W * 0.5 + Math.random() * W) / centerDist;
                x *= scaleFactor;
                y *= scaleFactor;
                z *= scaleFactor;
            }

            this.origX = x;
            this.origY = y;
            this.origZ = isInitial ? z : (W * 2 + Math.random() * W);

            this.x = this.origX;
            this.y = this.origY;
            this.z = this.origZ;

            // 预填充拖尾数组
            this.trail = [];
            for (let i = 0; i < this.trailLength; i++) {
                this.trail.push({
                    x: this.x,
                    y: this.y,
                    z: this.z
                });
            }

            // 重置拖尾可见度
            this.trailVisibility = 0;

            // 随机星星大小 - 增大变化范围，使星星大小差异更明显
            this.baseSize = 0.2 + Math.random() * 1.2;

            // 颜色选择
            let rnd = Math.random();
            let total = 0;
            for (const colorData of starColors) {
                total += colorData.prob;
                if (rnd <= total) {
                    this.color = colorData.color;
                    break;
                }
            }

            this.twinkleSpeed = 0.03 + Math.random() * 0.05;
            this.twinklePhase = Math.random() * Math.PI * 2;
            this.twinkleAmount = 0.1 + Math.random() * 0.3;
        }

        update() {
            // 移除最旧的位置
            if (this.trail.length >= this.trailLength) {
                this.trail.shift();
            }

            // 添加当前位置到拖尾
            this.trail.push({
                x: this.x,
                y: this.y,
                z: this.z
            });

            // 逐渐增加拖尾可见度
            this.trailVisibility = Math.min(1, this.trailVisibility + 0.02);

            // 使用随机速度更新位置
            this.origZ -= baseSpeed * 50 * this.speedFactor;

            // 重置并计算旋转
            this.x = this.origX;
            this.y = this.origY;
            this.z = this.origZ;

            // Y轴旋转 - 摄像机左右转头效果
            const cosY = Math.cos(currentAngleY);
            const sinY = Math.sin(currentAngleY);
            this.x = this.origX * cosY - this.origZ * sinY;
            this.z = this.origZ * cosY + this.origX * sinY;

            // 如果星星超出视野范围，重置到远处
            if (this.origZ < 1) {
                this.reset();
            }
        }

        draw() {
            // 透视投影
            const zOffset = 200;
            const scale = W / Math.max(1, this.z + zOffset);
            const sx = this.x * scale + W / 2;
            const sy = this.y * scale + H / 2;

            // 检查是否在屏幕范围内
            if (sx < -100 || sx > W + 100 || sy < -100 || sy > H + 100) return;

            // 闪烁效果
            const time = Date.now() * 0.001;
            const twinkle = 1 - this.twinkleAmount + this.twinkleAmount *
                Math.sin(time * this.twinkleSpeed + this.twinklePhase);

            // 计算星星大小和亮度
            const distanceFactor = Math.max(0, 1 - this.z / (W * 3));
            const size = Math.max(this.baseSize, 0.5 + distanceFactor * 4) * twinkle;

            // 调整亮度
            const alpha = Math.min(1, Math.max(0.3, 1.2 - this.z / (W * 2))) * twinkle;

            // ===== 增强拖尾效果 =====
            // 只有当拖尾历史记录有足够的点时才绘制拖尾
            if (this.trail.length >= 2) {
                // 计算拖尾各点的屏幕坐标
                const points = this.trail.map(point => {
                    const pointScale = W / Math.max(1, point.z + zOffset);
                    return {
                        x: point.x * pointScale + W / 2,
                        y: point.y * pointScale + H / 2,
                        z: point.z
                    };
                });

                // 添加当前位置
                points.push({x: sx, y: sy, z: this.z});

                // 计算拖尾中首尾两点的距离
                const firstPoint = points[0];
                const lastPoint = points[points.length-1];
                const trailDist = Math.sqrt(
                    Math.pow(lastPoint.x - firstPoint.x, 2) +
                    Math.pow(lastPoint.y - firstPoint.y, 2)
                );

                // 只有当拖尾有明显长度时才绘制
                if (trailDist > 3) {
                    // 使用曲线绘制拖尾，更加平滑
                    ctx.beginPath();
                    ctx.moveTo(points[0].x, points[0].y);

                    // 绘制拖尾 - 与星星颜色一致的渐变
                    const gradient = ctx.createLinearGradient(
                        points[0].x, points[0].y,
                        points[points.length-1].x, points[points.length-1].y
                    );

                    // 应用拖尾可见度
                    const visibleAlpha = alpha * this.trailVisibility;

                    // 完全透明的起点
                    gradient.addColorStop(0, 'rgba(0,0,0,0)');
                    // 中间点渐变 - 使用星星本身的颜色
                    const rgbValues = this.color.match(/\d+/g);
                    gradient.addColorStop(0.3, `rgba(${rgbValues[0]},${rgbValues[1]},${rgbValues[2]},${visibleAlpha * 0.1})`);
                    gradient.addColorStop(0.7, `rgba(${rgbValues[0]},${rgbValues[1]},${rgbValues[2]},${visibleAlpha * 0.5})`);
                    // 终点最亮 - 使用星星本身的颜色
                    gradient.addColorStop(1, `rgba(${rgbValues[0]},${rgbValues[1]},${rgbValues[2]},${visibleAlpha})`);

                    ctx.strokeStyle = gradient;
                    ctx.lineWidth = size * 0.8;

                    // 使用二次贝塞尔曲线连接点，使拖尾更平滑
                    for (let i = 1; i < points.length; i++) {
                        const xc = (points[i].x + points[i-1].x) / 2;
                        const yc = (points[i].y + points[i-1].y) / 2;
                        ctx.quadraticCurveTo(points[i-1].x, points[i-1].y, xc, yc);
                    }

                    // 连接到最后一个点
                    ctx.lineTo(points[points.length-1].x, points[points.length-1].y);
                    ctx.stroke();
                }
            }

            // 绘制星星本体
            ctx.fillStyle = this.color.replace('rgb', 'rgba').replace(')', `,${alpha})`);
            ctx.beginPath();
            ctx.arc(sx, sy, size, 0, Math.PI * 2);
            ctx.fill();

            // 增强发光效果 - 使用星星本身的颜色
            // 第一层光晕 - 较小但较亮
            const rgbValues = this.color.match(/\d+/g);
            const glow1 = ctx.createRadialGradient(sx, sy, 0, sx, sy, size * 2);
            glow1.addColorStop(0, `rgba(${rgbValues[0]},${rgbValues[1]},${rgbValues[2]},${alpha * 0.7 * this.glowIntensity})`);
            glow1.addColorStop(1, 'rgba(0,0,0,0)');

            ctx.fillStyle = glow1;
            ctx.beginPath();
            ctx.arc(sx, sy, size * 2, 0, Math.PI * 2);
            ctx.fill();

            // 第二层光晕 - 较大但较淡
            const glow2 = ctx.createRadialGradient(sx, sy, 0, sx, sy, size * this.glowSize * 2);
            glow2.addColorStop(0, `rgba(${rgbValues[0]},${rgbValues[1]},${rgbValues[2]},${alpha * 0.3 * this.glowIntensity})`);
            glow2.addColorStop(1, 'rgba(0,0,0,0)');

            ctx.fillStyle = glow2;
            ctx.beginPath();
            ctx.arc(sx, sy, size * this.glowSize * 2, 0, Math.PI * 2);
            ctx.fill();
        }
    }

    // 初始化星星
    for (let i = 0; i < numStars; i++) {
        stars.push(new Star(true));
    }

    // 动画循环
    function animate() {
        // 平滑过渡视角
        currentAngleY += (targetAngleY - currentAngleY) * 0.1;

        // 使用渐变背景
        ctx.fillStyle = bgGradient;
        ctx.fillRect(0, 0, W, H);

        // 绘制星空背景图片（如果已加载）
        if (bgImageLoaded) {
            // 计算背景图片位置 - 根据视角偏移
            const bgOffsetX = -currentAngleY * W / maxAngleY * 0.5;

            // 绘制背景图片 - 宽度大于屏幕以便有移动空间
            const bgWidth = W * 1.8;
            const bgHeight = H;
            const bgX = (W - bgWidth) / 2 + bgOffsetX;

            ctx.globalAlpha = 0.3;
            ctx.drawImage(bgImage, bgX, 0, bgWidth, bgHeight);
            ctx.globalAlpha = 1.0;
        }

        // 更新并绘制动态星星
        stars.forEach(star => {
            star.update();
            star.draw();
        });

        requestAnimationFrame(animate);
    }

    animate();

    // 鼠标移动控制视角
    window.addEventListener('mousemove', e => {
        const mx = (e.clientX / W) - 0.5;
        targetAngleY = mx * maxAngleY;
    });

    // 窗口大小变化时调整Canvas尺寸
    window.addEventListener('resize', () => {
        W = canvas.width = window.innerWidth;
        H = canvas.height = window.innerHeight;

        // 重新创建背景渐变
        bgGradient = ctx.createLinearGradient(0, 0, 0, H);
        bgGradient.addColorStop(0, '#010b18');
        bgGradient.addColorStop(0.5, '#050616');
        bgGradient.addColorStop(1, '#08071a');
    });

    // 触摸设备支持
    let touchX;
    window.addEventListener('touchstart', e => {
        if (e.touches.length === 1) e.preventDefault();
        touchX = e.touches[0].clientX;
    }, {passive: false});

    window.addEventListener('touchmove', e => {
        if (e.touches.length === 1) e.preventDefault();
        const mx = (e.touches[0].clientX / W) - 0.5;
        targetAngleY = mx * maxAngleY;
        touchX = e.touches[0].clientX;
    }, {passive: false});
</script>
</body>
</html>
